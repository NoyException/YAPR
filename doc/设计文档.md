# YAPR(Yet Another Poor Router)设计文档（潦草版）

## 概念

在本项目中，概念的定义如下：

- Router被定义为一组路由规则的集合，客户端可直接访问路由名
- Rule被定义为在请求符合任一Match的条件时使用某个Selector进行选择的规则
- Selector被定义为为某个Service的所有Endpoint按照策略进行选择的工具
- Service被定义为一组Endpoint的集合，他包含了所有服务端为该服务提供的Endpoint
- Endpoint被定义为一个IP地址
- URI被定义为访问的方法名

## 架构

![架构.png](arch.drawio.png)

如图，本项目使用的方案是在客户端进行路由。client在调用SDK初始化后会从数据库中获取路由信息，并在路由状态更新时及时从数据库同步。这些路由信息会实例化为router/selector/service三种对象，通过自定义resolver/balancer/picker让gRPC能使用router实例来创建subConns并选择正确的连接路由到对应的server。

## 控制平面与配置

数据库在未初始化时会由随机一个抢到锁的SDK通过配置文件初始化，需要初始化的数据包括：

- 数据库配置（etcd/redis）
- Selector配置
- Router配置

可参考[yapr.yaml](../deploy/yapr.yaml)

路由配置的保证正确的版本保存在etcd，每次更新配置都会通知所有服务（也就是说，由etcd充当控制平面）

而动态键值路由信息最初是实时从redis获取，后在此基础上添加一个LRU的buffer

## 服务注册

服务需要调用SDK来添加支持的服务，向Router添加Service到Endpoint的多重映射关系。每个服务器都会随机一个uuid，与该服务有关的Endpoint都会聚合在该uuid下，方便管理

这里使用了etcd的KeepAlive来进行保活，并通过Watch的方法在服务掉线后及时更新路由信息到各个SDK

## 服务发现

直接通过gRPC来发出服务请求，目标填写yapr:///RouterName(:Port)即可

在自定义的resolver中会尝试在本地获取Router，若没有则从数据库拉取相应数据（包括Router和他用到的Selectors和Services），同时对可能发生变化的字段进行Watch（Service下的Endpoint和他对应的属性）

## 路由策略

大致过程如下：

- 通过RouterName找到对应Router（没有就从数据库拉）
- 从Router中遍历Rules，找到第一个匹配的Rule
- 通过Rule中的SelectorName找到对应Selector
- 通过Selector中记录的ServiceName找到对应Service
- 在Service中查询获取所有可选Endpoint和他在该Selector中的属性
- 按照Selector的策略选择一个Endpoint转发

### （加权）随机【已实现】

（根据权重）随机一个Endpoint路由

### （加权）轮询【已实现】

（根据权重）轮流路由，在Service发生更新后Endpoint数组会被重新生成

### 最小代价【已实现】

服务端需要上报每个Endpoint的cost（被存储为weight，weight=MAX_INT-cost），选择一个cost最小的Endpoint进行路由

### 一致性哈希

需要在Selector中指定header key，然后根据header value进行哈希

> TODO：如果有新的服务加入或者旧的服务掉线，如何处理？

### 指定目标与动态键值

指定目标需要的参数有：

- SelectorName, HeaderValue
- Endpoint, Timeout

例如想设置玩家A对Zone服务的访问只能发送到目标B，那么参数的设置方法为：SelectorName=某个在Service`zone`上进行选择的选择器名
，HeaderKey=Selector.Key（这个Key自然是"player-id"），HeaderValue=`$A.id`，TargetID=`$B.id`，Timeout自由设置

> TODO：如果旧的服务掉线，如何处理？