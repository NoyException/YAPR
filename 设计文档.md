# YAPR(Yet Another Poor Router)设计文档（非常潦草版）

## 控制平面与配置

路由配置的保证正确的版本保存在etcd，每次更新配置都会通知所有服务（也就是说，由etcd充当控制平面）

一致性让etcd和redis来保证，参考[types.go](core%2Fproto%2Ftypes.go)，其中标星号的字段为可以修改的，需要监听的字段

部分路由信息需要从配置文件初始化，先初始化Service：

- Name（服务名）

然后初始化Selector：

- Name string（选择器名）
- Service string（服务名）
- Port uint32（端口）
- Strategy StrategyType（选择策略）
- Key string（哈希或指定目标策略的Header key）

最后给Router配置以下字段：

- Name string（路由名）
- Rules []Rule（路由规则）
- SelectorByName map[string]Selector
- ServiceByName map[string]Service

## 服务注册与配置

服务需要调用SDK来添加支持的服务，向router添加service到endpoint的多重映射关系

在服务注册时，对etcd进行以下操作：

- Put `Service_$Name/Exist_$Endpoint -> 1`

注册服务后，SDK自身会定期发起心跳来维护所有的endpoint

对直连的更新见下文

## 服务发现

需要通过SDK来发出服务请求，dial RouterName:Port

首先拉取完整的Router配置和Selector配置，然后对以下前缀注册监听：

- `Service_$Name/Exist_`（服务注册/掉线时都会触发更新，但由于每个endpoint只由对应的SDK修改，所以不会出现写冲突）
- `Selector_$Name/AttrMap_`（在属性修改时由endpoint对应的SDK更新）

## 路由过程

客户端在dial RouterName:
Port后，查询对应router，按照顺序匹配rule（在本项目中，每个Rule只允许拥有一个目的服务），使用匹配到的第一个rule指定的selector选择一个服务下的ip:
port

gRPC实现：每个router都会创建一个resolver/balancer/picker

## 路由策略

自定义gRPC resolver和LB

大致过程如下：

- 通过RouterName找到对应Router
- 从Router中遍历Rules，找到第一个匹配的Rule
- 通过Rule中的SelectorName找到对应Selector
- 通过Selector中记录的Service找到每个Endpoint和他在该Selector中的属性
- 按照Selector的策略选择一个Endpoint转发

### 随机

根据权重随机一个Endpoint路由

### RR

根据权重轮流路由，如果Endpoints更新则随机选择一个开始

### 一致性哈希

需要在策略中指定header key，然后根据header value进行哈希

> TODO：如果有新的服务加入或者旧的服务掉线，如何处理？

### 指定目标与动态键值

指定目标需要的参数有：

- SelectorName, HeaderValue
- Endpoint, Deadline

更新方法为在redis的名为`$SelectorName`的哈希表中加入键值对：`$HeaderValue -> $Endpoint`，并修改AttrMap
可以选择覆盖或者IfNotExists，用lua操作实现原子性

例如想设置玩家A对Zone服务的访问只能发送到目标B，那么参数的设置方法为：SelectorName=某个ServiceName是`zone`的选择器名
，HeaderKey=Selector.Key（这个Key自然是"player-id"），HeaderValue=`$A.id`，TargetID=`$B.id`，Deadline自由设置

> TODO：如果旧的服务掉线，如何处理？